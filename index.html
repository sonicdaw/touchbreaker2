<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Debugger: Cyber Crisis</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #gameCanvas {
            border: 2px solid #0f0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="384" height="416"></canvas>

    <script>
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 11;
        const CELL_SIZE = 32;
        const CANVAS_WIDTH = (GRID_WIDTH + 2) * CELL_SIZE;
        const CANVAS_HEIGHT = (GRID_HEIGHT + 2) * CELL_SIZE;

        let canvas, ctx;
        let player = { x: 0, y: 0 };
        let blocks = [];
        let bigBugs = [];
        let currentStep = 1;
        let gameState = 'playing';
        let cursorBlinkState = true;
        let lastBlinkTime = 0;

        const stageData = [
            { data: "0002A80A00A00A00A00A00A02A8000", x: 1, y: 11 },
            { data: "048040000000444444000000040240", x: 10, y: 11 },
            { data: "0000000A03B80000003B80A0000000", x: 5, y: 6 },
            { data: "00008010088000008001E00240A000", x: 3, y: 5 },
            { data: "0000002081F01101101F0208000000", x: 6, y: 7 },
            { data: "000000010108010000100200110000", x: 10, y: 11 },
            { data: "F1C80C00C1C00060061C000C80CF1C", x: 5, y: 1 },
            { data: "8044080000000400C0020000414800", x: 1, y: 9 },
            { data: "100094202000900010110400000004", x: 5, y: 11 },
            { data: "134220420880200000080108000000", x: 1, y: 11 },
            { data: "022400800824020000000102000000", x: 6, y: 1 },
            { data: "000000084008300300008084000000", x: 10, y: 11 }
        ];

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            loadStage(currentStep);
            document.addEventListener('keydown', handleKeyDown);
            gameLoop();
        }

        function loadStage(step) {
            const stage = stageData[step - 1];
            blocks = [];
            bigBugs = [];
            for (let col = 0; col < 10; col++) {
                const colData = stage.data.substr(col * 3, 3);
                const colBits = parseInt(colData, 16).toString(2).padStart(12, '0').slice(0, 11);
                for (let row = 0; row < 11; row++) {
                    if (colBits[row] === '1') {
                        blocks.push({ x: col, y: row, state: 'normal' });
                    }
                }
            }
            player = { x: stage.x - 1, y: stage.y - 1 };

            // ランダムに3つのビッグバグを配置
            for (let i = 0; i < 3; i++) {
                let randomBlock;
                do {
                    randomBlock = blocks[Math.floor(Math.random() * blocks.length)];
                } while (bigBugs.some(bug => bug.x === randomBlock.x && bug.y === randomBlock.y));
                bigBugs.push({ x: randomBlock.x, y: randomBlock.y, found: false });
            }
        }

        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(timestamp) {
            blocks.forEach(block => {
                if (isPlayerTouching(block)) {
                    block.state = 'selected';
                    const touchedBug = bigBugs.find(bug => bug.x === block.x && block.y === block.y);
                    if (touchedBug) touchedBug.found = true;
                } else if (block.state === 'selected') {
                    block.state = 'destroyed';
                }
            });

            blocks = blocks.filter(block => block.state !== 'destroyed');

            if (blocks.length === 0 || bigBugs.every(bug => bug.found)) {
                if (currentStep < 12) {
                    currentStep++;
                    loadStage(currentStep);
                } else {
                    gameState = 'allClear';
                }
            }

            // カーソルの点滅を更新
            if (timestamp - lastBlinkTime > 500) {  // 500ミリ秒ごとに点滅状態を切り替え
                cursorBlinkState = !cursorBlinkState;
                lastBlinkTime = timestamp;
            }
        }

        function draw() {
            // 背景（暗い青緑色）
            ctx.fillStyle = '#001a1a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 外周の壁（緑色の線）
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(CELL_SIZE, CELL_SIZE, CANVAS_WIDTH - 2 * CELL_SIZE, CANVAS_HEIGHT - 2 * CELL_SIZE);

            // ブロック（バグ）
            blocks.forEach(block => {
                const x = (block.x + 1) * CELL_SIZE;
                const y = (block.y + 1) * CELL_SIZE;
                ctx.fillStyle = block.state === 'normal' ? '#444' : '#888';
                ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                ctx.fillStyle = '#0f0';
                ctx.font = '10px Courier';
                ctx.fillText('BUG', x + 5, y + CELL_SIZE / 2);
            });

            // プレイヤー（点滅するカーソル）
            const playerX = (player.x + 1) * CELL_SIZE;
            const playerY = (player.y + 1) * CELL_SIZE;
            if (cursorBlinkState) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(playerX, playerY, CELL_SIZE, CELL_SIZE);
            }

            // ビッグバグの表示
            bigBugs.forEach((bug, index) => {
                ctx.beginPath();
                ctx.arc(CANVAS_WIDTH - 20 - index * 30, 20, 10, 0, Math.PI * 2);
                ctx.strokeStyle = '#f00';
                ctx.stroke();
                if (bug.found) {
                    ctx.fillStyle = '#f00';
                    ctx.fill();
                }
            });

            // ステージ情報
            ctx.fillStyle = '#0f0';
            ctx.font = '16px Courier';
            ctx.fillText(`MODULE: ${currentStep}/12`, 10, 20);

            if (gameState === 'allClear') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = '#0f0';
                ctx.font = '24px Courier';
                ctx.fillText('All Modules Debugged!', CANVAS_WIDTH / 2 - 150, CANVAS_HEIGHT / 2);
            }
        }

        function handleKeyDown(e) {
            if (gameState === 'allClear') return;

            let dx = 0, dy = 0;
            switch (e.code) {
                case 'ArrowLeft': dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                case 'ArrowUp': dy = -1; break;
                case 'ArrowDown': dy = 1; break;
                default: return;
            }
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            const blockAtNewPos = blocks.find(block => block.x === newX && block.y === newY);

            if (blockAtNewPos && canPushBlock(dx, dy)) {
                pushBlock(blockAtNewPos, dx, dy);
            } else if (canMove(dx, dy)) {
                player.x = newX;
                player.y = newY;
            }
        }

        function canMove(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT) {
                return false;
            }

            if (blocks.some(block => block.x === newX && block.y === newY)) {
                return false;
            }

            const checkPositions = [];
            if (dx !== 0) {
                checkPositions.push({x: player.x, y: player.y - 1});
                checkPositions.push({x: player.x, y: player.y + 1});
                checkPositions.push({x: newX, y: newY - 1});
                checkPositions.push({x: newX, y: newY + 1});
            } else {
                checkPositions.push({x: player.x - 1, y: player.y});
                checkPositions.push({x: player.x + 1, y: player.y});
                checkPositions.push({x: newX - 1, y: newY});
                checkPositions.push({x: newX + 1, y: newY});
            }

            return checkPositions.some(pos => 
                pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT ||
                blocks.some(block => block.x === pos.x && block.y === pos.y)
            );
        }

        function canPushBlock(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            const newBlockX = newX + dx;
            const newBlockY = newY + dy;

            if (newBlockX < 0 || newBlockX >= GRID_WIDTH || newBlockY < 0 || newBlockY >= GRID_HEIGHT ||
                blocks.some(block => block.x === newBlockX && block.y === newBlockY)) {
                return false;
            }

            const checkPositions = [];
            if (dx !== 0) {
                checkPositions.push({x: player.x, y: player.y - 1});
                checkPositions.push({x: player.x, y: player.y + 1});
                checkPositions.push({x: newX, y: newY - 1});
                checkPositions.push({x: newX, y: newY + 1});
            } else {
                checkPositions.push({x: player.x - 1, y: player.y});
                checkPositions.push({x: player.x + 1, y: player.y});
                checkPositions.push({x: newX - 1, y: newY});
                checkPositions.push({x: newX + 1, y: newY});
            }

            return checkPositions.some(pos => 
                pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT ||
                blocks.some(block => block.x === pos.x && block.y === pos.y)
            );
        }

        function pushBlock(block, dx, dy) {
            const newBlockX = block.x + dx;
            const newBlockY = block.y + dy;

            if (newBlockX >= 0 && newBlockX < GRID_WIDTH && newBlockY >= 0 && newBlockY < GRID_HEIGHT &&
                !blocks.some(b => b.x === newBlockX && b.y === newBlockY)) {
                block.x = newBlockX;
                block.y = newBlockY;
                player.x += dx;
                player.y += dy;
            }
        }

        function isPlayerTouching(block) {
            return Math.abs(player.x - block.x) <= 1 && Math.abs(player.y - block.y) <= 1;
        }

        window.onload = init;
    </script>
</body>
</html>
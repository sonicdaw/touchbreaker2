<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touch Breaker in WorldWide SystemDown</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #gameCanvas {
            border: 2px solid #0f0;
            touch-action: none;
        }
        #retryButton {
            margin-top: 10px;
            padding: 10px 20px;
            background-color: #001a1a;
            color: #0f0;
            border: 1px solid #0f0;
            cursor: pointer;
        }
        #gameTitle {
            font-size: 24px;
            margin-bottom: 10px;
            text-align: center;
        }
        #gameTitle .subtitle {
            font-size: 14px;
            display: block;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="gameTitle">
        Touch Breaker
        <span class="subtitle">WorldWide System Down</span>
    </div>
    <canvas id="gameCanvas" width="384" height="416"></canvas>
    <button id="retryButton">Retry</button>

    <script>
        const GRID_WIDTH = 10;
        const GRID_HEIGHT = 11;
        const CELL_SIZE = 32;
        const CANVAS_WIDTH = (GRID_WIDTH + 2) * CELL_SIZE;
        const CANVAS_HEIGHT = (GRID_HEIGHT + 2) * CELL_SIZE;

        let canvas, ctx;
        let player = { x: 0, y: 0 };
        let blocks = [];
        let npes = [];
        let currentStep = 1;
        let gameState = 'tutorial';
        let cursorBlinkState = true;
        let lastBlinkTime = 0;
        let tutorialStep = 0;
        let touchStartX, touchStartY;
        let explosions = [];
        let npePauseTimer = 0;
        let npeToExplode = null;

        const stageData = [
            { data: "000600000000000000000000600000", x: 1, y: 11 },
            { data: "0002A80A00A00A00A00A00A02A8000", x: 1, y: 11 },
            { data: "048040000000444444000000040240", x: 10, y: 11 },
            { data: "0000000A03B80000003B80A0000000", x: 5, y: 6 },
            { data: "00008010088000008001E00240A000", x: 3, y: 5 },
            { data: "0000002081F01101101F0208000000", x: 6, y: 7 },
            { data: "000000010108010000100200110000", x: 10, y: 11 },
            { data: "F1C80C00C1C00060061C000C80CF1C", x: 5, y: 1 },
            { data: "8044080000000400C0020000414800", x: 1, y: 9 },
            { data: "100094202000900010110400000004", x: 5, y: 11 },
            { data: "134220420880200000080108000000", x: 1, y: 11 },
            { data: "022400800824020000000102000000", x: 6, y: 1 },
            { data: "000000084008300300008084000000", x: 10, y: 11 }
        ];

        const tutorialMessages = [
            "壁、バグにそって移動できます",
            "バグに触れると、選択状態になります",
            "離れると、削除して駆除できます",
            "全てのバグを削除してクリアしましょう",
            "バグは押すこともできます",
            "押すバグ以外で移動できる場所だけ",
            "中央のバグを押して移動しながら消していこう"
        ];

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            loadStage(currentStep);
            document.addEventListener('keydown', handleKeyDown);

            canvas.addEventListener('touchstart', handleTouchStart, false);
            canvas.addEventListener('touchend', handleTouchEnd, false);

            document.getElementById('retryButton').addEventListener('click', retryStage);
            gameLoop();
        }

        function loadStage(step) {
            const stage = stageData[step - 1];
            blocks = [];
            npes = [];
            for (let col = 0; col < 10; col++) {
                const colData = stage.data.substr(col * 3, 3);
                const colBits = parseInt(colData, 16).toString(2).padStart(12, '0').slice(0, 11);
                for (let row = 0; row < 11; row++) {
                    if (colBits[row] === '1') {
                        blocks.push({ x: col, y: row, state: 'normal' });
                    }
                }
            }
            player = { x: stage.x - 1, y: stage.y - 1 };

            // ランダムに3つのビッグバグを配置
            for (let i = 0; i < 3; i++) {
                let randomBlock;
                do {
                    randomBlock = blocks[Math.floor(Math.random() * blocks.length)];
                } while (npes.some(bug => bug.x === randomBlock.x && bug.y === randomBlock.y));
                npes.push({ x: randomBlock.x, y: randomBlock.y, found: false });
            }
        }

        function gameLoop(timestamp) {
            update(timestamp);
            draw();
            requestAnimationFrame(gameLoop);
        }

        function update(timestamp) {
            if (npePauseTimer > 0) {
                npePauseTimer -= 1000 / 60; // Assuming 60 FPS
                if (npePauseTimer <= 0) {
                    npePauseTimer = 0;
                    if (npeToExplode) {
                        explodeNPE(npeToExplode);
                        npeToExplode = null;
                    }
                }
                return; // Skip other updates during pause
            }

            if (gameState === 'tutorial') {
                if (tutorialStep >= tutorialMessages.length - 1) {
                    gameState = 'playing';
                }
            }
            blocks = blocks.filter(block => block.state !== 'destroyed');
            if(blocks.length === 2){
                if(tutorialStep==2)tutorialStep++;
            }

            if (blocks.length === 0 && npePauseTimer === 0) {
                if (currentStep < 12) {
                    currentStep++;
                    loadStage(currentStep);
                    if(currentStep===3){
                        if(tutorialStep==3)tutorialStep++;
                    }
                } else {
                    gameState = 'beforeallClear';
                    npes.forEach(npe => explodeNPE(npe));
                }
            }

            if (explosions.length === 0 && gameState === 'beforeallClear') {
                gameState = 'allClear';
            }

            // カーソルの点滅を更新
            if (timestamp - lastBlinkTime > 500) {  // 500ミリ秒ごとに点滅状態を切り替え
                cursorBlinkState = !cursorBlinkState;
                lastBlinkTime = timestamp;
            }

            // Update explosions
            explosions = explosions.filter(explosion => {
                explosion.duration--;
                return explosion.duration > 0;
            });

            blocks.forEach(block => {
                if (isPlayerTouching(block)) {
                    block.state = 'selected';
                    if(tutorialStep==0) tutorialStep++;
                } else if (block.state === 'selected') {
                    block.state = 'destroyed';
                    if(tutorialStep==1) tutorialStep++;
                    const touchedNPE = npes.find(npe => npe.x === block.x && npe.y === block.y);
                    if (touchedNPE && !touchedNPE.found && currentStep > 1) {
                        touchedNPE.found = true;
                        npePauseTimer = 1000; // 1 second pause
                        npeToExplode = touchedNPE;
                    }
                }
            });
        }

        function explodeNPE(npe) {
            explosions.push({
                x: (npe.x + 1) * CELL_SIZE + CELL_SIZE / 2,
                y: (npe.y + 1) * CELL_SIZE + CELL_SIZE / 2,
                radius: 0,
                duration: 30
            });
        }

        function draw() {
            // 背景（暗い青緑色）
            ctx.fillStyle = '#001a1a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 外周の壁（緑色の線）
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(CELL_SIZE, CELL_SIZE, CANVAS_WIDTH - 2 * CELL_SIZE, CANVAS_HEIGHT - 2 * CELL_SIZE);

            // ブロック（バグ）
            blocks.forEach(block => {
                const x = (block.x + 1) * CELL_SIZE;
                const y = (block.y + 1) * CELL_SIZE;
                ctx.fillStyle = block.state === 'normal' ? '#444' : '#888';
                ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                ctx.fillStyle = '#0f0';
                ctx.font = '10px Courier';
                ctx.fillText('BUG', x + 5, y + CELL_SIZE / 2);
            });

            // プレイヤー（点滅するカーソル）
            const playerX = (player.x + 1) * CELL_SIZE;
            const playerY = (player.y + 1) * CELL_SIZE;
            if (cursorBlinkState) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(playerX, playerY, CELL_SIZE, CELL_SIZE);
            }

            // Draw explosions
            explosions.forEach(explosion => {
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 0, 0, ${explosion.duration / 60})`;
                ctx.fill();
                explosion.radius += (60 - explosion.duration) / 2;
            });

            // Draw NPE during pause
            if (npePauseTimer > 0 && npeToExplode) {
                ctx.beginPath();
                ctx.arc((npeToExplode.x + 1) * CELL_SIZE + CELL_SIZE / 2 , (npeToExplode.y + 1) * CELL_SIZE + CELL_SIZE / 2, 13, 0, Math.PI * 2);
                ctx.strokeStyle = '#f00';
                ctx.stroke();
                ctx.fillStyle = '#f00';
                ctx.font = '10px Courier';
                ctx.fillText('NPE', (npeToExplode.x + 1) * CELL_SIZE + 7, (npeToExplode.y + 1) * CELL_SIZE + CELL_SIZE / 2 + 3);
            }

            // ステージ情報
            ctx.fillStyle = '#0f0';
            ctx.font = '16px Courier';
            ctx.fillText(`MODULE: ${currentStep}/12`, 10, 20);

            if (gameState === 'allClear') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.fillStyle = '#0f0';
                ctx.font = '24px Courier';
                ctx.fillText('All Modules Debugged!', CANVAS_WIDTH / 2 - 150, CANVAS_HEIGHT / 2);
            }

            if (gameState === 'tutorial' && currentStep != 2) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, CANVAS_HEIGHT / 2 - 60, CANVAS_WIDTH, 60);
                ctx.fillStyle = '#0f0';
                ctx.font = '14px Courier';
                ctx.textAlign = 'center';
                ctx.fillText(tutorialMessages[tutorialStep], CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
                ctx.textAlign = 'left';
            }

            if(currentStep > 1){
                // Draw NPEs
                npes.forEach((npe, index) => {
                    ctx.beginPath();
                    ctx.arc(CANVAS_WIDTH - 20 - index * 30, 17, 13, 0, Math.PI * 2);
                    ctx.strokeStyle = '#f00';
                    ctx.stroke();
                    if (npe.found) {
                        ctx.fillStyle = '#f00';
                        ctx.fill();
                    }
                    ctx.fillStyle = '#f00';
                    ctx.font = '10px Courier';
                    ctx.fillText('NPE', CANVAS_WIDTH - 28 - index * 30, 20);
                });
            }

            if(currentStep > 2){
                blocks.forEach(block => {
                    if (isPlayerTouching(block)) {
                        if(block.x == player.x || block.y == player.y){
                            drawPushArrows(block);
                        }
                    }
                });
            }
        }

        function drawPushArrows(block) {
            const directions = [
                { dx: 1, dy: 0, arrow: '→' },
                { dx: -1, dy: 0, arrow: '←' },
                { dx: 0, dy: 1, arrow: '↓' },
                { dx: 0, dy: -1, arrow: '↑' }
            ];

            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            directions.forEach(dir => {
                if (block.x - player.x == dir.dx && block.y - player.y == dir.dy  && canPushBlock(dir.dx, dir.dy)) {
                    const arrowX = (block.x + 1.5 + dir.dx * 0.5) * CELL_SIZE;
                    const arrowY = (block.y + 1.5 + dir.dy * 0.5) * CELL_SIZE;
                    ctx.fillText(dir.arrow, arrowX, arrowY);
                }
            });
            ctx.textAlign = 'start';
            ctx.textBaseline = 'alphabetic';
        }

        function handleTouchStart(e) {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) {
                    movePlayer(1, 0);
                } else {
                    movePlayer(-1, 0);
                }
            } else {
                if (dy > 0) {
                    movePlayer(0, 1);
                } else {
                    movePlayer(0, -1);
                }
            }
        }

        function retryStage() {
            loadStage(currentStep);
        }

        function handleKeyDown(e) {
            if (gameState === 'allClear') return;

            if (e.code === 'KeyR') {
                // Rキーが押されたらステージをリセット
                loadStage(currentStep);
                return;
            }

            let dx = 0, dy = 0;
            switch (e.code) {
                case 'ArrowLeft': dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                case 'ArrowUp': dy = -1; break;
                case 'ArrowDown': dy = 1; break;
                default: return;
            }

            movePlayer(dx, dy);
        }

        function movePlayer(dx, dy) {
            if (gameState === 'allClear' || npePauseTimer != 0) return;

            const newX = player.x + dx;
            const newY = player.y + dy;
            const blockAtNewPos = blocks.find(block => block.x === newX && block.y === newY);

            if (blockAtNewPos && canPushBlock(dx, dy)) {
                pushBlock(blockAtNewPos, dx, dy);
                if(tutorialStep==4)tutorialStep++;
            } else if (canMove(dx, dy)) {
                player.x = newX;
                player.y = newY;
                if(newX > 2 && newX < 7 && newY > 3 && newY < 7){
                    if(tutorialStep==5)tutorialStep++;
                }
            }
        }

        function canMove(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT) {
                return false;
            }

            if (blocks.some(block => block.x === newX && block.y === newY)) {
                return false;
            }

            const checkPositions = [];
            if (dx !== 0) {
                checkPositions.push({x: player.x, y: player.y - 1});
                checkPositions.push({x: player.x, y: player.y + 1});
                checkPositions.push({x: newX, y: newY - 1});
                checkPositions.push({x: newX, y: newY + 1});
            } else {
                checkPositions.push({x: player.x - 1, y: player.y});
                checkPositions.push({x: player.x + 1, y: player.y});
                checkPositions.push({x: newX - 1, y: newY});
                checkPositions.push({x: newX + 1, y: newY});
            }

            return checkPositions.some(pos => 
                pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT ||
                blocks.some(block => block.x === pos.x && block.y === pos.y)
            );
        }

        function canPushBlock(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;
            const newBlockX = newX + dx;
            const newBlockY = newY + dy;

            if (newBlockX < 0 || newBlockX >= GRID_WIDTH || newBlockY < 0 || newBlockY >= GRID_HEIGHT ||
                blocks.some(block => block.x === newBlockX && block.y === newBlockY)) {
                return false;
            }

            // Check if there's a block at the new player position
            const blockAtNewPos = blocks.find(block => block.x === newX && block.y === newY);
            if (!blockAtNewPos) return false;

            // Check if the new block position is valid
            if (newBlockX < 0 || newBlockX >= GRID_WIDTH || newBlockY < 0 || newBlockY >= GRID_HEIGHT ||
                blocks.some(block => block.x === newBlockX && block.y === newBlockY)) {
                return false;
            }

            const checkPositions = [];
            if (dx !== 0) {
                checkPositions.push({x: player.x, y: player.y - 1});
                checkPositions.push({x: player.x, y: player.y + 1});
                checkPositions.push({x: newX, y: newY - 1});
                checkPositions.push({x: newX, y: newY + 1});
            } else {
                checkPositions.push({x: player.x - 1, y: player.y});
                checkPositions.push({x: player.x + 1, y: player.y});
                checkPositions.push({x: newX - 1, y: newY});
                checkPositions.push({x: newX + 1, y: newY});
            }

            return checkPositions.some(pos => 
                pos.x < 0 || pos.x >= GRID_WIDTH || pos.y < 0 || pos.y >= GRID_HEIGHT ||
                blocks.some(block => block.x === pos.x && block.y === pos.y)
            );
        }

        function pushBlock(block, dx, dy) {
            const newBlockX = block.x + dx;
            const newBlockY = block.y + dy;

            if (newBlockX >= 0 && newBlockX < GRID_WIDTH && newBlockY >= 0 && newBlockY < GRID_HEIGHT &&
                !blocks.some(b => b.x === newBlockX && b.y === newBlockY)) {
                block.x = newBlockX;
                block.y = newBlockY;
                player.x += dx;
                player.y += dy;
            }
        }

        function isPlayerTouching(block) {
            return Math.abs(player.x - block.x) <= 1 && Math.abs(player.y - block.y) <= 1;
        }

        window.onload = init;
    </script>
</body>
</html>